# Self Introduction  
구조 설계와 안정성에 집중하는 개발자

---

## 1. 개발 철학 – 구조는 결과가 아니라 출발점이다

저는 개발을 기능을 쌓는 일이 아니라, **시스템이 유지될 수 있는 형태를 설계하는 일**로 봅니다. 기능은 언제든 변하지만, 구조는 그 변화를 흡수해야 합니다. 그래서 코드를 작성할 때 가장 먼저 고민하는 것은 "이 로직이 어디에 속해야 하는가"입니다. 이는 단순한 코드 정리가 아니라, 시스템의 방향성을 결정하는 작업입니다.

구조를 안정적으로 만드는 가장 중요한 기준은 **복원력과 관찰 가능성**이라고 생각합니다. 예외 상황이 언제든 발생할 수 있기 때문에, 에러를 처리할 뿐 아니라 복구 경로를 설계해야 한다고 봅니다. 또한 로그에는 시간, 프로세스 ID, 스레드 ID, 레벨을 포함해 동시성 환경에서도 상태를 추적할 수 있게 합니다. 이런 체계가 있어야 시스템은 "정상 동작"이 아니라 "이해 가능한 동작"을 합니다.

협업에서도 구조적 사고는 같은 역할을 합니다. 기능 논의가 아니라 **책임의 경계**를 중심으로 대화를 이끌고, 설계 의도를 시각적으로 표현해 불필요한 해석을 줄입니다. 논쟁이 생기면 옳고 그름이 아니라 **의존 방향과 책임 분리 기준**으로 판단합니다.  
결국 제가 말하는 개발의 본질은 빠른 구현이 아니라, **이해 가능한 구조를 통해 예측 가능한 시스템을 만드는 일**입니다.

---

## 2. 핵심 역량 – 구조로 일관성을 설계하다

제가 가장 중시하는 역량은 **시스템의 구조적 일관성을 유지하는 설계 능력**입니다. 새로운 기능을 추가하더라도 전체 흐름이 무너지지 않도록, 구조의 틀 안에서 변화를 흡수할 수 있게 설계하는 편입니다. 이를 위해 Layered Architecture를 기본으로 두고, 의존성 역전(DIP)을 통해 하위 모듈이 상위 정책에 종속되지 않게 합니다. 기능보다 구조가 먼저 정립되어야, 변화가 들어올 때 수정이 아니라 확장이 가능합니다.

예를 들어 **무선 공유기 관리 프로토콜 암호화 프로젝트**에서는 암호화 키 교환 로직이 여러 네트워크 환경에서 예외를 발생시키는 문제가 있었습니다. 단순히 오류를 수정하지 않고 **정책 단위로 로직을 재구성**했습니다. 재시도 정책, 타임아웃 정책, 로그 정책을 각각 독립된 모듈로 분리해, 상황별로 교체 가능한 구조를 만들었습니다. 그 결과 시스템의 복원력이 높아졌고, 장애 대응 시 정책 조정만으로 대응할 수 있게 되었습니다.

또한 **REST API 서버 개발**에서는 구조적 일관성을 프레임워크 수준으로 확장했습니다. 임베디드 환경에서도 Express처럼 미들웨어 기반의 요청 흐름을 구현하기 위해, Router–Middleware–Adapter–Logger 구조를 직접 설계했습니다. 각 계층은 단일 책임만을 갖도록 설계했고, 외부 의존성(Civetweb, Mongoose)은 어댑터 레이어를 통해서만 접근하도록 했습니다.  
이 방식은 코드 품질을 높이기보다는, **시스템을 예측 가능한 형태로 유지하기 위한 구조적 안정화 과정**이었습니다.

협업 측면에서도 구조 중심의 사고는 중요한 역할을 합니다. 기능 요청이 들어올 때 "무엇을 할 것인가"보다 "어디에 둘 것인가"를 먼저 논의합니다. 설계 도면이나 계층 다이어그램을 함께 보며 의존 방향을 정리하고, 책임 경계를 명확히 하는 대화를 선호합니다. 이 과정을 통해 개발자 간 해석 차이를 줄이고, 코드 리뷰 시에도 구조적 기준으로 피드백할 수 있는 환경을 만듭니다.

결국 제가 가진 강점은 특정 기술 스택에 대한 숙련도보다는, **시스템이 오랜 시간 유지될 수 있도록 구조를 설계하고 일관성을 관리하는 능력**입니다. 복잡한 문제일수록 구조가 무너지기 쉽지만, 그 속에서도 균형을 유지하는 것이 제가 가장 자신 있는 영역입니다.

---

## 3. 성장 과정 – 기능에서 구조로, 구조에서 체계로

처음 개발을 시작했을 때 저는 "작동하는 코드"를 만드는 데 집중했습니다. 요구사항을 구현하고 오류 없이 동작하면 충분하다고 생각했습니다. 하지만 시스템이 커질수록, 기능이 정상적으로 돌아가더라도 전체 구조는 점점 무너져갔습니다. 어느 순간부터 "작동"보다 "유지"가 더 어렵다는 사실을 체감했습니다. 이때부터 저는 코드보다 구조를 보기 시작했습니다.

**oceancloud 프로젝트** 진행 중의 리팩토링 경험이 전환점이었습니다. 초기에 단일 모듈 안에 로직이 얽혀 있어 유지보수가 어렵다는 점을 문제로 인식했고, 단순히 성능을 개선하는 대신 "왜 이 구조가 불안정한가"를 분석했습니다. 그 결과, 기능이 아니라 **책임 단위로 코드를 분리해야 한다**는 결론에 도달했습니다. 그 이후로는 코드 작성보다 먼저 계층과 책임 경계를 정의하고, 각 모듈이 어떤 정책을 따를지부터 명확히 하는 습관이 자리 잡았습니다.

이 변화는 임베디드 개발로 전환 후의 리팩토링에서도 이어졌습니다. 팀 내부에 웹 구조를 이해하는 인력이 부족했기 때문에, 직접 구조 기준을 제안하고 적용했습니다. 특히 **세션 관리, API 응답 구조 통일** 등 공통 규칙을 정립하여 팀 전체가 같은 언어로 코드를 이해할 수 있도록 했습니다. 그 과정에서 깨달은 것은, **구조적 일관성은 설득이 아니라 설명으로 이뤄지는 합의**라는 점이었습니다.

최근에는 **무선 공유기 관리 프로토콜 암호화 프로젝트**와 **REST API 서버 개발**을 통해 이러한 구조적 감각을 체계화했습니다. 단순히 코드를 분리하는 수준을 넘어, **정책과 책임의 경계를 명확히 하여 프레임워크 단위의 구조**를 직접 설계했습니다. Layered + Hexagonal 아키텍처를 기반으로, 시스템의 변화를 안정적으로 수용할 수 있는 틀을 만들었습니다.  
지금의 저는 코드를 작성하기보다, 코드가 **이해될 수 있는 형태로 존재하도록 만드는 것**에 집중합니다. 기능 중심의 개발자가 아니라, **구조를 통해 복잡함을 제어하는 개발자**로 성장했다고 생각합니다.

---

## 4. 지향점 – 이해 가능한 시스템을 향하여

제가 지향하는 개발은 **복잡한 시스템을 단순하게 보이게 만드는 일**입니다. 기능이 많아질수록 구조는 무거워지고, 코드가 늘어날수록 시스템은 읽히지 않게 됩니다. 그렇기 때문에 앞으로도 **이해 가능한 구조**, 즉 읽을 수 있고 설명할 수 있는 시스템을 만드는 데 집중하려 합니다.  
좋은 시스템은 빠르게 구현된 것이 아니라, 시간이 지나도 일관성을 잃지 않는 시스템이라고 믿습니다.

이를 위해 설계 단계에서부터 "어떻게 동작할지"보다 "어떻게 이해될지"를 우선합니다. 구조가 명확하면 버그의 원인은 자연히 좁혀지고, 협업 중의 논의 또한 기능이 아닌 **경계 중심의 대화**로 진행됩니다. 결국 개발자의 역할은 기능을 구현하는 것이 아니라, **팀과 시스템 모두가 신뢰할 수 있는 질서를 설계하는 일**이라고 생각합니다.

앞으로는 이러한 구조적 사고를 한 단계 더 확장해, **프레임워크 단위의 구조 설계**에 집중하고자 합니다. REST API 서버 개발을 통해 경험한 Layered + Hexagonal 아키텍처의 가능성을 바탕으로, **도메인 독립적이면서도 운영 환경에 유연한 구조**를 연구하고 있습니다.  
제가 만들고 싶은 것은 완벽한 코드가 아니라, **변화 속에서도 스스로 균형을 유지할 수 있는 시스템**, 즉 이해 가능한 질서입니다.

---

## 5. 클린 코드 – 사고의 질서를 드러내는 언어

저에게 클린 코드는 **규칙이 아니라 사고의 질서를 드러내는 언어**입니다. 코드는 단순히 동작을 기술하는 수단이 아니라, 시스템이 어떻게 이해되어야 하는지를 보여주는 표현 방식입니다.

따라서 클린 코드를 "짧은 코드"나 "간결한 문법"으로 보지 않습니다. 오히려 **읽히는 구조**, **맥락이 보이는 이름**, **책임이 명확한 함수**를 우선합니다. 코드를 읽는 사람에게 "이 시스템은 이렇게 구성되어 있다"는 논리적 질서가 전달되어야 진정한 의미의 클린 코드라고 생각합니다.

이를 위해 모든 조건문에는 중괄호를 사용하고, 부정 표현보다 명시적 비교를 택하며, 에러는 항상 코드와 메시지 쌍으로 다룹니다. 이런 규칙은 스타일을 위한 것이 아니라, **사람이 코드를 해석할 때의 오차를 최소화하기 위한 설계적 장치**입니다. 구조가 명확하면 실수는 줄고, 코드 리뷰나 디버깅에서도 논리 단위로 대화할 수 있습니다.

결국 클린 코드는 미학이 아니라 **이해 가능한 질서를 구축하기 위한 약속**입니다. 저는 이 약속을 코드 한 줄에서 시스템 전체까지 일관되게 유지하려 합니다. 그렇게 쌓인 코드는 단순히 동작하는 결과물이 아니라, **사유가 축적된 구조물**이 됩니다.

---
